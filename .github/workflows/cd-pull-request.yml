name: CD - Pull Request

on:
  workflow_call:
    inputs:
      main_branch:
        description: 'Main branch (default: main)'
        required: false
        type: string
        default: "main"
      develop_branch:
        description: 'Develop branch (default: develop)'
        required: false
        type: string
        default: "develop"

      pr_title:
        description: 'Title for the Pull Request'
        required: false
        type: string
        default: "üîÄ PR ({{yyyy-MM-dd}}): {{HEAD_BRANCH}} ‚Üí {{BASE_BRANCH}}"

      pr_body:
        description: 'Body for the Pull Request (default changes made by this workflow)'
        required: false
        type: string

      pr_body_path:
        description: 'Path for the Pull Request body. Takes priority over `pr_body`'
        required: false
        type: string

    secrets:
      GH_TOKEN:
        required: true

permissions:
  contents: write       # ‚Üí permite criar e atualizar tags, commits e pushes no reposit√≥rio.
  pull-requests: write  # ‚Üí se precisar criar ou atualizar pull requests
  checks: read          # ‚Üí (opcional) se precisar ler check runs

jobs:
  resolve-branch:
    runs-on: ubuntu-latest
    outputs:
      head: ${{ steps.resolve.outputs.head }}
      base: ${{ steps.resolve.outputs.base }}
      skip: ${{ steps.resolve.outputs.skip }}

    steps:
    - name: üîç Resolve branches
      id: resolve
      run: |
        HEAD="${{ github.event.workflow_run.head_branch || github.head_ref || github.ref_name }}"
        MAIN="${{ inputs.main_branch }}"
        DEV="${{ inputs.develop_branch }}"
        REL_PREFIX="${{ inputs.prefix_release_branch }}"

        if [[ "$HEAD" == "$MAIN" ]]; then
          echo "skip=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [[ "$HEAD" == "$DEV" ]]; then
          BASE="$MAIN"
        else
          BASE="$DEV"
        fi

        echo "üîπ Pull Request: $HEAD ‚Üí $BASE"

        echo "base=$BASE" >> $GITHUB_OUTPUT
        echo "head=$HEAD" >> $GITHUB_OUTPUT
        echo "skip=false" >> $GITHUB_OUTPUT

    - name: üö´ Skip - main branch detected
      if: steps.resolve.outputs.skip == 'true'
      run: echo "‚Üí Main branch detected. Skipping auto PR."

  read-quality:
    needs: resolve-branch
    if: needs.resolve-branch.outputs.skip != 'true'
    runs-on: ubuntu-latest

    outputs:
      hasQuality: ${{ steps.quality.outputs.hasQuality }}
      hasCoverage: ${{ steps.quality.outputs.hasCoverage }}
      hasCommitlint: ${{ steps.quality.outputs.hasCommitlint }}

      coverage: ${{ steps.quality.outputs.coverage }}

    steps:
    - name: üîé Read quality check
      id: quality
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GH_TOKEN }}
        script: |
          // tenta pegar SHA de diferentes contextos 
          const sha = context.payload?.workflow_run?.head_sha || context.payload?.pull_request?.head?.sha || context.payload?.after || context.sha; 

          if (!sha) { 
            core.setOutput("status", "missing"); 
            console.log("‚ö†Ô∏è Nenhum HASH encontrado no contexto"); 
            return; 
          }

          console.log("hash: ", sha);

          const checks = await github.rest.checks.listForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: sha
          });

          const check = checks.data.check_runs.find(c => c.name === "actions-flow/quality");

          if (!check) {
            core.setOutput("hasQuality", false);
            return;
          }

          const match = check.output.text?.match(/```json\n([\s\S]*?)\n```/);

          if (!match) {
            core.setOutput("hasQuality", false);
            return;
          }

          const data = JSON.parse(match[1]);

          const hasCoverage = !!(data?.coverage);
          const hasCommit = !!(data?.commitlint);

          core.setOutput("hasQuality", hasCoverage && hasCommit);
          core.setOutput("hasCoverage", hasCoverage);
          core.setOutput("hasCommitlint", hasCommit);

          if (hasCoverage) {
            core.setOutput("coverage", data.coverage);
          }

          if (hasCommit) {
            core.setOutput("commitlint", data.commitlint);
          }

          console.log("üìä Quality Result: ", data);

  auto-pr:
    needs:
    - resolve-branch
    - read-quality
    if: needs.resolve-branch.outputs.skip != 'true'
    runs-on: ubuntu-latest

    env:
      REUSABLE_PATH: ${{ github.workspace }}/__reusable_files__
      BASH_ENV: ${{ github.workspace }}/__reusable_files__/scripts/shared/shell-helpers.sh

    steps:
    - name: üìå Checkout consumer repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Necess√°rio para evitar falhas do gh CLI em reposit√≥rios grandes
        token: ${{ secrets.GH_TOKEN }} # Necess√°rio se o reposit√≥rio for privado

    - name: üìå Checkout reusable repository
      uses: actions/checkout@v4
      with:
        repository: heliomarpm/actions-flow
        ref: main
        path: ${{ env.REUSABLE_PATH }}
        fetch-depth: 1

    - name: üîê Auth GitHub CLI
      run: |
        # echo "${GITHUB_TOKEN}" | gh auth login --with-token
        gh auth setup-git
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

    # -------------------------------------------------
    # Validar branch destino de forma determin√≠stica
    # -------------------------------------------------
    - name: üîé Ensure Destination Branch
      if: needs.resolve-branch.outputs.skip != 'true'
      run: |
        set -e

        BASE="${{ needs.resolve-branch.outputs.base }}"

        log "Checking branch: $BASE"

        if ! git show-ref --verify --quiet "refs/remotes/origin/$BASE"; then
          {
            echo "## ‚ùå Invalid destination branch"
            echo ""
            echo "Branch \`$BASE\` does not exist in repository."
            echo ""
            echo "### Available branches:"
            # git branch -r
            git ls-remote --heads origin | awk '{print $2}' | sed 's|refs/heads/||'
          } >> "$GITHUB_STEP_SUMMARY"

          log "Expected branch: $BASE"
          exit 1
        fi

    - name: üè∑ Ensure labels exist
      if: needs.resolve-branch.outputs.skip != 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
      run: |
        ensure_label "auto-generated" "Pull Request criada automaticamente" 006B75
        ensure_label "coverage-failed" "Cobertura de testes abaixo do limite m√≠nimo" D93F0B
        ensure_label "coverage-passed" "Cobertura de testes adequado" 0E8A16
        ensure_label "coverage-missing" "Sem testes ou cobertura de testes" E99695

    - name: üìù Generate PR body
      if: needs.resolve-branch.outputs.skip != 'true'
      # working-directory: ${{ steps.path.outputs.value }}
      run: |
        log "hasCoverage ${{ needs.read-quality.outputs.hasCoverage }}"

        if [ -n "${{ inputs.pr_body_path }}" ]; then
          PR_BODY_PATH="${{ inputs.pr_body_path }}"
          log "Usando atributo \`pr_body_path\`: $PR_BODY_PATH"

          if [ ! -f "$PR_BODY_PATH" ]; then
            fail "PR body file \`not found\`: $PR_BODY_PATH"
          fi          
          PR_TEMPLATE="$(cat $PR_BODY_PATH)"
        elif [ -n "${{ inputs.pr_body }}" ]; then 
          log "Usando atributo \`pr_body\`"
          PR_TEMPLATE="${{ inputs.pr_body  }}"
        fi

        if ! [ -v PR_TEMPLATE ]; then
          log "Usando template padr√£o"
          PR_TEMPLATE=$(cat "${{ env.REUSABLE_PATH }}/.github/templates/pr_template.md")
        fi

        STATUS_DISPLAY="‚ûñ"
        COVERAGE_BLOCK="missing"
        COV_LINE="${{ fromJson(needs.read-quality.outputs.coverage).line }}"

        # Verifica se o template cont√©m a chave para bloco de qualidade
        if [[ "$PR_TEMPLATE" == *"{{QUALITY_GATE_RESULT}}"* ]]; then

          TITLE_BLOCK="üìä Cobertura de Testes"

          if [[ -n "$COV_LINE" ]]; then
            COVERAGE_BLOCK="found"
          else
            COVERAGE_BLOCK="not-found"
          fi        
        fi

        log "COVERAGE_BLOCK: $COVERAGE_BLOCK"

        if [ "$COVERAGE_BLOCK" = "found" ]; then
          COV_BASE="${{ fromJson(needs.read-quality.outputs.coverage).base }}"
          COV_LINE="${{ fromJson(needs.read-quality.outputs.coverage).line }}"
          COV_DELTA="${{ fromJson(needs.read-quality.outputs.coverage).delta }}"
          COV_MIN="${{ fromJson(needs.read-quality.outputs.coverage).min }}"
          COV_STATUS="${{ fromJson(needs.read-quality.outputs.coverage).status }}"
          COV_MODE="${{ fromJson(needs.read-quality.outputs.coverage).mode }}"
          COV_REASON="${{ fromJson(needs.read-quality.outputs.coverage).reason }}"
          COV_INTERPRETATION="${{ fromJson(needs.read-quality.outputs.coverage).interpretation }}"

          if [ "$COV_STATUS" = "passed" ]; then
            STATUS_DISPLAY="‚úÖ"
          else
            STATUS_DISPLAY="‚ùå"
          fi
          STATUS_DISPLAY+=" \`$COV_STATUS\`"
          
          QUALITY_BLOCK=$(cat <<EOF
        ---
        ### $TITLE_BLOCK

        > $COV_INTERPRETATION

        | M√©trica | Valor  |
        |-------- |------- |
        | Branch Base  | **$COV_BASE%** |
        | Linhas  | **$COV_LINE%** |
        | Delta  | $COV_DELTA |
        | M√≠nimo requerido | $COV_MIN% |
        | Modo | \`$COV_MODE\` |
        | Status | $STATUS_DISPLAY |

        EOF
        )
        elif [ "$COVERAGE_BLOCK" = "not-found" ]; then
          QUALITY_BLOCK=$(cat <<EOF
        ---
        ### $TITLE_BLOCK  

        > ‚ö†Ô∏è Cobertura n√£o gerada para este projeto.

        EOF
        )          
        else
          QUALITY_BLOCK=""
        fi

        log "QUALITY_BLOCK: $QUALITY_BLOCK"

        # Substitui os placeholders 
        PR_TEMPLATE=${PR_TEMPLATE//\{\{HEAD_BRANCH\}\}/"${{ needs.resolve-branch.outputs.head }}"} 
        PR_TEMPLATE=${PR_TEMPLATE//\{\{BASE_BRANCH\}\}/"${{ needs.resolve-branch.outputs.base }}"} 
        PR_TEMPLATE=${PR_TEMPLATE//\{\{QUALITY_GATE_RESULT\}\}/"$QUALITY_BLOCK"} 

        echo "$PR_TEMPLATE" > pr_body.md

    - name: üìú Create or Update Pull Request
      id: create-pr
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
      run: |
        set -e

        HEAD="${{ needs.resolve-branch.outputs.head }}"
        BASE="${{ needs.resolve-branch.outputs.base }}"
        TITLE="${{ inputs.pr_title || 'PR $HEAD ‚Üí $BASE' }}"

        TITLE=${TITLE//\{\{yyyy-MM-dd\}\}/$(date +'%Y-%m-%d')}
        TITLE=${TITLE//\{\{HEAD_BRANCH\}\}/$HEAD}
        TITLE=${TITLE//\{\{BASE_BRANCH\}\}/$BASE}

        STATUS_COVERAGE="${{ fromJson(needs.read-quality.outputs.coverage).status }}"
        if [ "$STATUS_COVERAGE" = "failed" ]; then
          ADD_LABEL="coverage-failed"
          DEL_LABEL="coverage-passed,coverage-missing"
        elif [ "$STATUS_COVERAGE" = "passed" ]; then
          ADD_LABEL="coverage-passed"
          DEL_LABEL="coverage-failed,coverage-missing"
        elif [ "$STATUS_COVERAGE" = "missing" ]; then
          ADD_LABEL="coverage-missing"
          DEL_LABEL="coverage-passed,coverage-failed"
        fi

        # Tenta encontrar um PR existente
        PR_NUMBER=$(gh pr list --base "$BASE" --head "$HEAD" --json number --jq '.[0].number')

        echo "$TITLE"
        if [ -z "$PR_NUMBER" ]; then
          echo "‚Üí No existing PR found. Creating new PR..."
          gh pr create \
            --base "$BASE" \
            --head "$HEAD" \
            --title "$TITLE" \
            --body-file pr_body.md \
            --label "auto-generated,$ADD_LABEL" \
            --assignee "${{ github.actor }}"

          PR_URL=$(gh pr view "$HEAD" --json url --jq '.url')
          PR_ACTION="created"
        else
          echo "‚Üí Existing PR #$PR_NUMBER found. Updating..."
          gh pr edit "$PR_NUMBER" \
            --title "$TITLE" \
            --body-file pr_body.md \
            --add-assignee "${{ github.actor }}" \
            --remove-label "$DEL_LABEL" \
            --add-label "$ADD_LABEL"

          PR_URL="https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          PR_ACTION="updated"
        fi

        # Saida para Anotations do workflow
        echo "::notice title=Auto PR ${PR_ACTION}::${HEAD} ‚Üí ${BASE}"
        echo "::notice title=Pull Request::${PR_URL}"

        echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
        echo "pr_action=$PR_ACTION" >> $GITHUB_OUTPUT

    - name: üßæ Job Summary
      if: always()
      run: |
        COV_STATUS="${{ fromJson(needs.read-quality.outputs.coverage).status }}"
        if [ "$COV_STATUS" = "failed" ]; then
          STATUS_DISPLAY="‚ùå"
        else
          STATUS_DISPLAY="‚úÖ"
        fi
        STATUS_DISPLAY+=" \`$COV_STATUS\`"

        cat <<EOF >> $GITHUB_STEP_SUMMARY
        ## üîÄ Auto Pull Request

        **Status:** \`${{ steps.create-pr.outputs.pr_action || 'processed' }}\`

        **From:** \`${{ needs.resolve-branch.outputs.head }}\`  
        **To:** \`${{ needs.resolve-branch.outputs.base }}\`

        ---
        ### üìä Coverage

        > ${{ fromJson(needs.read-quality.outputs.coverage).interpretation }}

        | Metric      | Value                                       |
        |------------ |-------------------------------------------- |
        | Base Branch | ${{ fromJson(needs.read-quality.outputs.coverage).base }}%     |
        | Coverage    | **${{ fromJson(needs.read-quality.outputs.coverage).line }}%** |
        | Delta Œî     | ${{ fromJson(needs.read-quality.outputs.coverage).delta }}     |
        | Minimum     | ${{ fromJson(needs.read-quality.outputs.coverage).min }}%      |
        | Mode        | \`${{ fromJson(needs.read-quality.outputs.coverage).mode }}\`  |
        | Status      | $STATUS_DISPLAY                             |
        | Reason      | \`${{ fromJson(needs.read-quality.outputs.coverage).reason }}\`|
                
        ---
        üîó **PR:** ${{ steps.create-pr.outputs.pr_url || '<failed>' }}

        ---
        _Gerado automaticamente pela action **auto-pr**_
        EOF
