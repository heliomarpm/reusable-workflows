name: CI - Quality Assurance

on:
  workflow_call:
    inputs:
      stack:
        description: 'Stack the project. (node | php | dotnet | python | go | empty for auto-detect)'
        required: false
        type: string
        default: "auto"
      project_path:
        description: 'Project path source code'
        required: false
        type: string
        default: "."

      coverage_base_branch:
        description: 'Base branch for comparative coverage (decrease mode) (default: main)'
        required: false
        type: string
        default: "main"
      coverage_command:
        description: 'Command to calculate coverage percentage'
        required: false
        type: string
      coverage_min:
        description: 'Minimum coverage percentage (0-100 | default: 80)'
        type: number
        required: false
        default: 80
      coverage_strict_mode:
        description: 'Coverage mode (info | block | decrease)'
        type: string
        required: false
        default: "info"

    secrets:
      GH_TOKEN:
        description: 'GitHub Token for private consumer repositories'
        required: false

# concurrency:
#   group: ci-quality-${{ github.ref }}
#   cancel-in-progress: true
permissions:
  contents: write       # ‚Üí permite criar e atualizar tags, commits e pushes no reposit√≥rio.
  checks: write         # ‚Üí permite criar e atualizar check run

jobs:
  quality:
    runs-on: ubuntu-latest

    env:
      BASH_ENV: ${{ github.workspace }}/__reusable_files__/scripts/shared/shell-helpers.sh
      REUSABLE_PATH: ${{ github.workspace }}/__reusable_files__
      QUALITY_FILE: ${{ github.workspace }}/quality-result.json

    steps:
    - name: üìå Checkout consumer repository
      uses: actions/checkout@v4
      with: 
        token: ${{ secrets.GH_TOKEN || github.token }}

    - name: üìå Checkout reusable repository
      uses: actions/checkout@v4
      with:
        repository: heliomarpm/reusable-workflows
        ref: main # ${{ github.ref }}
        path: ${{ env.REUSABLE_PATH }}

    - name: üìê Resolve project path
      id: path
      run: |
        PROJECT_PATH="$(resolve_project_path '${{ inputs.project_path }}')"
        log "üîπ Using project path: $PROJECT_PATH"
        echo "value=$PROJECT_PATH" >> "$GITHUB_OUTPUT"

    - name: üëÄ Files in workspace
      working-directory: ${{ steps.path.outputs.value }}
      run: |
        ls_files

    - name: üîç Resolve project stack
      id: stack
      working-directory: ${{ steps.path.outputs.value }}
      run: |
        STACK="${{ inputs.stack }}"
        if [[ -n "$STACK" && "$STACK" != "auto" ]]; then
          echo "üîπ Using stack from input: $STACK"
          echo "value=$STACK" >> $GITHUB_OUTPUT
          echo "source=input" >> $GITHUB_OUTPUT
          exit 0
        fi

        SCRIPT="$REUSABLE_PATH/scripts/shared/detect-stack.sh"
        chmod +x "$SCRIPT"
        STACK=$("$SCRIPT" "${{ steps.path.outputs.value }}")

        echo "value=$STACK" >> $GITHUB_OUTPUT
        echo "source=detected" >> $GITHUB_OUTPUT

    - name: ‚ùå Fail if stack not detected
      if: steps.stack.outputs.value == ''
      run: fail "Stack not detected. Check project_path or repository structure."

    - name: ‚ñ∂Ô∏è Run unit tests
      working-directory: ${{ steps.path.outputs.value }}
      run: |
        STACK="${{ steps.stack.outputs.value }}"
        SCRIPT="$REUSABLE_PATH/scripts/plugins/$STACK/test.sh"
        chmod +x "$SCRIPT"
        $SCRIPT

    - name: üìä Run coverage tests
      id: head-coverage
      continue-on-error: true
      working-directory: ${{ steps.path.outputs.value }}
      env:
        COVERAGE_COMMAND: ${{ inputs.coverage_command }}
      run: |
        STACK="${{ steps.stack.outputs.value }}"
        SCRIPT="$REUSABLE_PATH/scripts/plugins/$STACK/coverage.sh"
        chmod +x "$SCRIPT"

        $SCRIPT || true

    - name: üìâ Get base branch coverage (for decrease mode)
      id: base-coverage
      continue-on-error: true
      working-directory: ${{ steps.path.outputs.value }}
      env:
        COVERAGE_COMMAND: ${{ inputs.coverage_command }}
      run: |
        BASE_REF="${{ github.base_ref || inputs.coverage_base_branch }}"

        log "Base branch: $BASE_REF"

        if [ -z "$BASE_REF" ]; then
          log "No base ref detected (not a PR). Skipping."
          echo "line=0" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "Checking out base branch: $BASE_REF"

        git fetch origin "$BASE_REF" --depth=1
        git checkout "$BASE_REF"

        STACK="${{ steps.stack.outputs.value }}"
        SCRIPT="$REUSABLE_PATH/scripts/plugins/$STACK/coverage.sh"
        chmod +x "$SCRIPT"

        "$SCRIPT" || true
        
        # Volta para branch original
        git checkout -

    - name: üõ°Ô∏è Evaluate coverage
      id: eval-coverage
      run: |
        MIN=${{ inputs.coverage_min }}
        MODE="${{ inputs.coverage_strict_mode }}"
        HEAD_LINE=${{ steps.head-coverage.outputs.line || 0 }}
        BASE_LINE=${{ steps.base-coverage.outputs.line || 0 }}

        BELOW_MIN=$(awk "BEGIN {print ($HEAD_LINE < $MIN)}")
        DELTA=$(awk "BEGIN {print ($HEAD_LINE - $BASE_LINE)}")

        if [ "$BELOW_MIN" -eq 1 ]; then
          STATUS="failed"
          REASON="below-minimum"
          INTERPRETATION="A cobertura est√° **abaixo** do limite m√≠nimo. Adicione mais testes antes de mesclar."
        elif [ "$MODE" = "decrease" ] && [ "$DELTA" -lt 0 ]; then
          STATUS="failed"
          REASON="coverage-decreased"
          INTERPRETATION="A cobertura diminuiu. Adicione mais testes antes de mesclar."
        else
          STATUS="passed"
          REASON="coverage-enough"
          INTERPRETATION="A cobertura est√° **de acordo** com o limite exigido."
        fi

        if [ "$STATUS" = "failed" ]; then
          if [ "$MODE" = "block" ]; then
            fail echo "‚ùå Coverage below threshold ($LINE < $MIN)"
          
          elif [ "$MODE" = "decrease" ]; then
            fail echo "‚ùå Coverage decreased ($LINE < $BASE_LINE)"
          fi
        fi

        FILE="${{ steps.head-coverage.outputs.file  }}"
        cat <<EOF > "$FILE"
        {
          "status": "$STATUS",
          "line": $HEAD_LINE,
          "base": $BASE_LINE,
          "delta": "$DELTA",
          "min": $MIN,
          "mode": "$MODE",
          "reason": "$REASON",
          "interpretation": "$INTERPRETATION"
        }
        EOF

        echo "file=$FILE" >> $GITHUB_OUTPUT
        echo "base=$BASE_LINE" >> $GITHUB_OUTPUT
        echo "line=$HEAD_LINE" >> $GITHUB_OUTPUT
        echo "delta=$DELTA" >> $GITHUB_OUTPUT
        echo "min=$MIN" >> $GITHUB_OUTPUT
        echo "status=$STATUS" >> $GITHUB_OUTPUT
        echo "mode=$MODE" >> $GITHUB_OUTPUT
        echo "reason=$REASON" >> $GITHUB_OUTPUT
        echo "interpretation=$INTERPRETATION" >> $GITHUB_OUTPUT

        echo "--------------------------------------"
        log "Status: $STATUS"
        log "Head Coverage: $HEAD_LINE%"
        log "Base Coverage: $BASE_LINE%"
        log "Delta: $DELTA"
        log "Minimum: $MIN%"
        log "Mode: $MODE"
        log "Reason: $REASON"
        log "Interpretation: $INTERPRETATION"
        echo "--------------------------------------"

    - name: ‚ñ∂Ô∏è Run validate commitlint
      id: commitlint
      run: |
        SCRIPT="$REUSABLE_PATH/scripts/core/versioning/engine.sh"
        chmod +x "$SCRIPT"

        $SCRIPT validate

    - name: ‚öôÔ∏è Write Quality Result 
      id: write-quality-result
      run: |
        COV_FILE=${{ steps.eval-coverage.outputs.file }}
        COMMIT_FILE=${{ steps.commitlint.outputs.file }}

        FILE="${{ env.QUALITY_FILE }}"

        cat <<EOF > "$FILE"
        {
          "coverage": $(cat "$COV_FILE"),
          "commitlint": $(cat "$COMMIT_FILE")
        }
        EOF

    - name: üì• Upload Artifact Quality Result
      uses: actions/upload-artifact@v4
      continue-on-error: true
      with:
        name: quality-report-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}
        path: ${{ env.QUALITY_FILE }}
        if-no-files-found: ignore

    - name: üì• Upload Checks Quality Result 
      if: always()
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const fs = require('fs');
          const result = JSON.parse(fs.readFileSync(process.env.QUALITY_FILE, 'utf8'));
                
          const coverageFailed = result.coverage.mode !== "info" && result.coverage.status === "failed";
          const commitFailed = result.commitlint.commit.valid === false;
          const conclusion = (coverageFailed || commitFailed) ? "failure" : "success";

          await github.rest.checks.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            name: "reusable-workflows/quality",
            head_sha: context.sha,
            status: "completed",
            conclusion,
            output: {
              title: "Quality Report",
              summary: "Actions Flow - Quality check",
              text: "```json\n" + JSON.stringify(result, null, 2) + "\n```"
            }
          });

    - name: üßæ Job Summary
      if: always()
      # working-directory: ${{ github.workspace }} 
      run: |
        {
          echo "## üß™ Quality Gate "
          echo ""
          echo "**üìÇ Project path:** \`${{ inputs.project_path || './'}}\`"
          echo ""

          if [[ "${{ steps.stack.outputs.value }}" != "" ]]; then
            echo "**üß± Stack:** \`${{ steps.stack.outputs.value }}\` (_${{ steps.stack.outputs.source }}_)"
          else
            echo "**üß± Stack:** ‚ùå \`not detected\`"
          fi

          echo ""
          echo "---"
          if [[ "${{ steps.eval-coverage.outputs.status }}" == "passed" ]]; then
            if [[ -n "${{ steps.eval-coverage.outputs.line }}" ]]; then
              echo "**üìä Coverage:** \`${{ steps.eval-coverage.outputs.line }}%"\`
            else
              echo "**üìä Coverage:** \`executed\` (no summary produced) | mode: \`${{ steps.eval-coverage.outputs.mode }}"\`
            fi
          elif [[ "${{ steps.eval-coverage.outputs.status }}" == "failed" ]]; then
            echo "**üìä Coverage:** \`failed\` | mode: \`${{ steps.eval-coverage.outputs.mode }}"\`
          else
            echo "**üìä Coverage:** \`not executed\` | mode: \`${{ steps.eval-coverage.outputs.mode }}"\`
          fi

          echo ""
          if [ -n "${{ steps.eval-coverage.outputs.reason }}" ]; then
            echo "**Reason:** ${{ steps.eval-coverage.outputs.reason }}"
          fi
          
          if [ "${{ steps.eval-coverage.outputs.status }}" = "failed" ]; then
            STATUS_DISPLAY="‚ùå"
          else
            STATUS_DISPLAY="‚úÖ"
          fi
          STATUS_DISPLAY+=" \`${{ steps.eval-coverage.outputs.status }}\`"

          DELTA="${{ steps.eval-coverage.outputs.delta }}"
          if [ "$DELTA" -gt 0 ]; then
            DELTA_DISPLAY="üìà +$DELTA%"
          elif [ "$DELTA" -lt 0 ]; then
            DELTA_DISPLAY="üìâ $DELTA%"
          else
            DELTA_DISPLAY="‚ûñ 0%"
          fi

          echo ""
          echo "> ${{ steps.eval-coverage.outputs.interpretation }}"
          echo ""
          echo "| Metric      | Value                                         |"
          echo "|------------ |---------------------------------------------- |"
          echo "| Base Branch | ${{ steps.eval-coverage.outputs.base }}%      |"
          echo "| Coverage    | **${{ steps.eval-coverage.outputs.line }}%**  |"
          echo "| Delta Œî     | $DELTA_DISPLAY                                |"
          echo "| Minimum     | ${{ steps.eval-coverage.outputs.min }}%       |"
          echo "| Mode        | \`${{ steps.eval-coverage.outputs.mode }}\`   |"
          echo "| Status      | $STATUS_DISPLAY                               |"
          echo "| Reason      | \`${{ steps.eval-coverage.outputs.reason }}\` |"

          # echo ""
          # echo "### üßæ Commit Validation"
          # echo ""
          # echo "| Valid | Release Type | Next Version |"
          # echo "|-------|-------------|----------|"
          # echo "| ${{ steps.commitlint.validation.valid }} | ${{ steps.commitlint.mode }} | ${{ steps.commitlint.version.next }} |"

          if [ -f "${{ env.QUALITY_FILE }}" ]; then
            echo ""
            echo "---"
            echo "**üì¶ Artifacts:** quality-report"
          fi
        } >> $GITHUB_STEP_SUMMARY
